---
title : 'Prompt'
date : 2024-09-30T22:30:13+08:00
lastmod: 2024-09-30T22:20:13+08:00
description : "Prompt Engineering" 
categories : ["Prompt"]
tags : ["Prompt"]
---

# Prompt

```
要求：字数尽可能多，内容需要全面，可以不按照我的标题来写，可以适当添加一些内容，但是内容一定一定要多，要专业
```

```
请根据以上内容以及你的数据库内容，撰写 ： 
数据处理与分析 海浪波谱仪采集的数据需要经过复杂的处理与分析，才能生成有用的波谱图。数据处理过程包括去噪、滤波、频谱分析等步骤。常用的频谱分析方法包括快速傅里叶变换（FFT）和小波变换等。通过对海浪频谱的分析，可以提取出海浪的主导频率、波高分布、能量谱等重要信息。


详细
```

```
我现在需要写实验报告，请缩写上部分内容，但是不要损失其表达的意思
```





## 文章生成

```prompt
“我想写一篇科普文章，标题是：‘[在此处插入你的标题]’。你能帮我分析一下这个标题吗？它是否有吸引力，有没有可以改进的地方来增强其吸引力？”
文章生成：

“在优化标题后，帮我生成一篇文章。文章的目标是向读者科普关于[插入主题]的知识。请确保内容易于普通读者理解，同时保持科学的准确性和趣味性。文章应包括以下部分：引言、定义、示例、现实应用以及结论。语气要保持信息性，但尽量亲切、易懂。”
```



## 朗读内容

```
先重复下面的内容，然后加一个简短的总结
```



## Leetcode题目总结

```
下面我给出一个题目，代码实现，和对题目的总结和实现思路， 你需要的是学习我是如何总结的，如果你看懂了则回复我你懂了, 不用回复别的
"""
给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 n - 1 ，且恰好有 n - 1 条边，每个节点有一个值。树的 根节点 为 0 号点。

给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。nums[i] 表示第 i 个点的值，edges[j] = [uj, vj] 表示节点 uj 和节点 vj 在树中有一条边。

当 gcd(x, y) == 1 ，我们称两个数 x 和 y 是 互质的 ，其中 gcd(x, y) 是 x 和 y 的 最大公约数 。

从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。

请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。

 

示例 1：



输入：nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
输出：[-1,0,0,1]
解释：上图中，每个节点的值在括号中表示。
- 节点 0 没有互质祖先。
- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。
- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。
- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。
示例 2：



输入：nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
输出：[-1,0,-1,0,0,0,-1]
 

提示：

nums.length == n
1 <= nums[i] <= 50
1 <= n <= 105
edges.length == n - 1
edges[j].length == 2
0 <= uj, vj < n
uj != vj


代码实现：
class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        n = len(nums)
        g = [[]*n for _ in range(n)]
        ret = [-1]*n
        store = [[] for _ in range(51)]
        mem = [(-1, -1)]*(51) 

        for i in range(1, 51):
            for j in range(1, 51):
                if gcd(i, j)==1:
                    store[i].append(j)

        for u, v in edges:
            g[u].append(v)
            g[v].append(u)

        def dfs(u, last, level):
            ret[u] = max(mem[i] for i in store[nums[u]])[1]
            tmp = mem[nums[u]]
            mem[nums[u]] = (level, u)
            for son in g[u]:
                if son==last:
                    continue
                dfs(son, u, level+1)
            mem[nums[u]] = tmp

        dfs(0, -1, 0)

        return ret
"""
```

```
好的，你现在需要做的是 ： 我给你其他题目，并给出已经AC的代码实现，你需要补充：1、题目大意 2、实现思路
如果你已经了解了我的需求，请回复我懂了
```

